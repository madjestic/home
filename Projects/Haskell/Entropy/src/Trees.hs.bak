module Trees
( sumLeaves
) where

import Data.Tree


-- debug trees
tree0 = Node {rootLabel = "0", subForest = []}
tree1 = Node {rootLabel = "1", subForest = []}
tree2 = Node {rootLabel = "2", subForest = []}
tree21 = Node {rootLabel = "21", subForest = tree2:tree1:[]}
tree321 = Node {rootLabel = "321", subForest = tree2:tree1:tree21:[]}
tree231 = Node {rootLabel = "231", subForest = tree2:tree21:tree1:[]}
tree321321=Node{rootLabel="321321",subForest = tree321:tree321:[]}
tree231231=Node{rootLabel="231231",subForest = tree231:tree231:[]}

root = Node {rootLabel = "root", subForest = tree0:tree1:tree2:tree321:tree21:tree0:[]}
-- end of debug trees

-- | Neat 2-dimensional drawing of a tree.
drawTree' :: Tree String -> String
drawTree'  = unwords . draw

draw :: Tree String -> [String]
draw (Node x ts0) = x : drawSubTrees ts0
  where
    drawSubTrees [] = []
    drawSubTrees [t] =
        "|" : shift "`- " "   " (draw t)
    drawSubTrees (t:ts) =
        "|" : shift "+- " "|  " (draw t) ++ drawSubTrees ts

    shift first other = zipWith (++) (first : repeat other)


sumStrings :: [String] -> Int
sumStrings [] = 0
sumStrings xs = foldr1 (+) $ map read xs


leaf :: Eq a => Tree a -> Bool
leaf tree
		| subForest tree == [] = True
		| otherwise           = False
		
-- children function - return the number of children of a node:%
--children


--leaves' :: [Tree [Char]] -> [Tree [Char]]
--leaves' [] 			= []
--leaves' st@(t:ts)
--	| leaf t    = t : leaves' ts
--	| otherwise = Node {rootLabel = "0", subForest = leaves' (subForest t)} : leaves' ts


leaves :: Tree [Char] -> Tree [Char]
leaves node tree

-- how do you define a specific node of a tree?

		| leaf tree == True = tree
		| otherwise        = Node {rootLabel = "0", subForest = leaves_from (subForest tree)}
		                                                  where leaves_from [] = []
		                                                        leaves_from st@(t:ts)
	                                                                         | leaf t    = t : leaves_from ts	
	                                                                         | otherwise = Node {rootLabel = "0", subForest = leaves_from (subForest t)} : leaves_from ts
	
sumLeaves :: Tree [Char] -> Int
sumLeaves t = sumStrings $ flatten $ leaves t
